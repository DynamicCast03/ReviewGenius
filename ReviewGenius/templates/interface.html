<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>ReviewGenius - 智能出题</title>
		<link
			href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
			rel="stylesheet"
		/>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
		<style>
			body {
				background-color: #f8f9fa;
			}
			.container {
				max-width: 1200px;
			}
			.card-header strong {
				font-size: 1.1rem;
			}
		</style>
	</head>
	<body>
		<div id="alert-container" class="position-fixed top-0 start-50 translate-middle-x p-3" style="z-index: 1056; width: fit-content;">
			<!-- Dynamic alerts will be injected here -->
		</div>
		<div class="container mt-5">
			<div class="text-center mb-5 d-flex justify-content-center align-items-center">
				<h1 class="me-3">ReviewGenius 智能出题系统</h1>
				<button type="button" class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#settingsModal">
					<i class="bi bi-gear"></i>
				</button>
			</div>

			<div class="row g-5">
				<div class="col-md-4">
					<form id="generate-form">
						<input type="hidden" id="temperature" name="temperature" value="1.0">
						<div class="mb-3">
							<label class="form-label fw-bold">1. 管理参考资料</label>
							<div id="file-management-area">
								<ul class="list-group mb-2" id="file-list">
									<!-- 文件列表将通过JS动态加载 -->
								</ul>
								<div class="input-group">
									<input type="file" class="form-control" id="new-file-upload" multiple>
									<button class="btn btn-outline-secondary" type="button" id="upload-btn">
										<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
										上传
									</button>
								</div>
							</div>
						</div>
						<div class="mb-3">
							<label for="api_key" class="form-label fw-bold"
								>2. 输入API Key</label
							>
							<input
								type="password"
								class="form-control"
								id="api_key"
								name="api_key"
								placeholder="请输入 SiliconFlow API Key"
								required
							/>
						</div>
						<div class="mb-3">
							<label for="user_input" class="form-label fw-bold"
								>3. 输入额外要求 (可选)</label
							>
							<textarea
								class="form-control"
								id="user_input"
								name="user_input"
								rows="3"
								placeholder="例如：请侧重于XX章节的知识点"
							></textarea>
						</div>
						<div class="mb-4">
							<label class="form-label fw-bold">4. 设置题型和数量</label>
							<div class="row g-2 mb-2">
								<div class="col">
									<label for="choice_count" class="form-label"
										>选择题</label
									>
									<input
										type="number"
										class="form-control"
										id="choice_count"
										name="choice_count"
										value="0"
										min="0"
									/>
								</div>
								<div class="col">
									<label for="blank_count" class="form-label"
										>填空题</label
									>
									<input
										type="number"
										class="form-control"
										id="blank_count"
										name="blank_count"
										value="0"
										min="0"
									/>
								</div>
								<div class="col">
									<label for="short_count" class="form-label"
										>简答/计算题</label
									>
									<input
										type="number"
										class="form-control"
										id="short_count"
										name="short_count"
										value="1"
										min="0"
									/>
								</div>
							</div>
							<div class="row g-2">
								<div class="col">
									<label for="choice_score" class="form-label">分值</label>
									<input type="number" class="form-control" id="choice_score" name="choice_score" value="5" min="1">
								</div>
								<div class="col">
									<label for="blank_score" class="form-label">分值</label>
									<input type="number" class="form-control" id="blank_score" name="blank_score" value="5" min="1">
								</div>
								<div class="col">
									<label for="short_score" class="form-label">分值</label>
									<input type="number" class="form-control" id="short_score" name="short_score" value="10" min="1">
								</div>
							</div>
						</div>
						<button
							type="submit"
							class="btn btn-primary w-100 btn-lg"
							id="generate-btn"
						>
							<span
								class="spinner-border spinner-border-sm d-none"
								role="status"
								aria-hidden="true"
							></span>
							生成试卷
						</button>
					</form>
				</div>

				<div class="col-md-8">
					<h4>生成的题目</h4>
					<div
						id="questions-container"
						class="mt-3"
						style="min-height: 400px"
					>
						<!-- 流式生成的卡片将出现在这里 -->
						<div
							class="alert alert-secondary text-center"
							id="start-generation-placeholder"
						>
							点击"生成试卷"开始出题
						</div>
					</div>
					<div id="controls-container" class="mt-3 text-center"></div>
				</div>
			</div>
		</div>

		<!-- Export Options Modal -->
		<div class="modal fade" id="exportMarkdownModal" tabindex="-1" aria-labelledby="exportMarkdownModalLabel" aria-hidden="true">
			<div class="modal-dialog modal-dialog-centered">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title" id="exportMarkdownModalLabel">选择导出选项</h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
						<p>请选择答案在 Markdown 文件中的位置：</p>
						<div class="d-grid gap-2">
							<button type="button" class="btn btn-outline-primary" id="export-inline-btn">答案紧跟在每道题后面</button>
							<button type="button" class="btn btn-outline-primary" id="export-end-btn">所有答案集中在文档末尾</button>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Settings Modal -->
		<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title" id="settingsModalLabel">设置</h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
						<div class="form-group">
							<label for="temperature-slider">模型温度 (Temperature): <span id="temperature-value">1.0</span></label>
							<input type="range" class="custom-range" id="temperature-slider" min="0" max="2" step="0.1" value="1.0">
							<small class="form-text text-muted">值越高，回答越随机和有创造性；值越低，回答越确定和保守。</small>
						</div>
						<div class="form-check">
							<input class="form-check-input" type="checkbox" value="" id="enhanced-structured-output">
							<label class="form-check-label" for="enhanced-structured-output">
								增强型结构化输出 (实验性)
							</label>
							<small class="form-text text-muted">开启后，将会附加调用一次小模型对输出数据进行格式化检查，返回更
								稳定的结构化数据。会导致流式输出首字出现前需要一定时间的等待。</small>
						</div>
						<!-- 用户画像编辑区 -->
						<div class="form-group mt-4">
							<label for="user-profile-editor">用户画像 (User Profile)</label>
							<textarea class="form-control" id="user-profile-editor" rows="6"></textarea>
							<small class="form-text text-muted">在这里查看和编辑您的学习画像。此画像将影响未来的出题和评分风格。</small>
						</div>
					</div>
					<div class="modal-footer">
						<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
						<button type="button" class="btn btn-primary" id="save-settings">保存设置</button>
					</div>
				</div>
			</div>
		</div>

		<div style="height: 80vh;"></div> <!-- 增加空白，使得页面可以向下滚动 -->

		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
		<!-- 引入 Socket.IO 客户端库 -->
		<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
		<script>
			document.addEventListener('DOMContentLoaded', function() {
				// API Key记忆功能
				const apiKeyInput = document.getElementById('api_key');
				const savedApiKey = localStorage.getItem('siliconflow_api_key');
				if (savedApiKey) {
					apiKeyInput.value = savedApiKey;
				}

				apiKeyInput.addEventListener('input', function() {
					localStorage.setItem('siliconflow_api_key', apiKeyInput.value);
				});

				// === 文件管理逻辑 START ===
				const fileList = document.getElementById('file-list');
				const newFileUpload = document.getElementById('new-file-upload');
				const uploadBtn = document.getElementById('upload-btn');
				const uploadBtnSpinner = uploadBtn.querySelector('.spinner-border');
				const uploadBtnText = uploadBtn.lastChild;

				function renderFileList(files) {
					fileList.innerHTML = ''; // 清空现有列表
					if (!files || files.length === 0) {
						fileList.innerHTML = '<li class="list-group-item text-muted small">尚未上传任何参考资料</li>';
					} else {
						files.forEach(filename => {
							const li = document.createElement('li');
							li.className = 'list-group-item d-flex justify-content-between align-items-center';
							
							const fileNameSpan = document.createElement('span');
							fileNameSpan.textContent = filename;
							fileNameSpan.style.wordBreak = 'break-all';

							const deleteBtn = document.createElement('button');
							deleteBtn.className = 'btn btn-danger btn-sm';
							deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
							deleteBtn.type = 'button';
							deleteBtn.onclick = () => deleteFile(filename);

							li.appendChild(fileNameSpan);
							li.appendChild(deleteBtn);
							fileList.appendChild(li);
						});
					}
				}

				// WebSocket 连接
				const socket = io();

				socket.on('connect', function() {
					console.log('成功连接到服务器!');
				});

				socket.on('file_list_update', function(data) {
					console.log('收到文件列表更新:', data.files);
					renderFileList(data.files);
				});

				socket.on('disconnect', function() {
					console.log('与服务器断开连接。');
				});

				async function uploadFiles() {
					const files = newFileUpload.files;
					if (files.length === 0) {
						showAlert('请先选择要上传的文件', 'warning');
						return;
					}

					uploadBtn.disabled = true;
					uploadBtnSpinner.classList.remove('d-none');
					uploadBtnText.textContent = ' 上传中...';

					const formData = new FormData();
					for (const file of files) {
						formData.append('files', file);
					}

					try {
						const response = await fetch('/api/upload', {
							method: 'POST',
							body: formData
						});
						const result = await response.json();
						if (!response.ok) {
							let errorMsg = result.message || '上传失败';
							if (result.errors) {
								errorMsg += ': ' + Object.entries(result.errors).map(([k, v]) => `${k} (${v})`).join(', ');
							}
							throw new Error(errorMsg);
						}
						
						if (result.uploaded_files && result.uploaded_files.length > 0) {
							showAlert(`${result.uploaded_files.join(', ')} 上传成功`, 'success');
						} else if (response.status === 200) {
							showAlert(result.message || '上传成功', 'success');
						}
						
						newFileUpload.value = ''; // 清空文件选择框
						// UI更新将由WebSocket事件处理
					} catch (error) {
						console.error('Upload error:', error);
						showAlert(`上传出错: ${error.message}`, 'danger');
					} finally {
						uploadBtn.disabled = false;
						uploadBtnSpinner.classList.add('d-none');
						uploadBtnText.textContent = '上传';
					}
				}

				async function deleteFile(filename) {
					if (!confirm(`确定要删除文件 "${filename}" 吗？`)) {
						return;
					}
					try {
						const response = await fetch(`/api/files/${encodeURIComponent(filename)}`, {
							method: 'DELETE'
						});
						const result = await response.json();
						if (!response.ok) {
							throw new Error(result.error || '删除失败');
						}
						showAlert(result.message, 'success');
						// UI更新将由WebSocket事件处理
					} catch (error) {
						console.error('Delete error:', error);
						showAlert(`删除文件失败: ${error.message}`, 'danger');
					}
				}

				// 绑定事件
				uploadBtn.addEventListener('click', uploadFiles);

				// === 文件管理逻辑 END ===

				// Settings Modal Logic
				const temperatureSlider = document.getElementById('temperature-slider');
				const temperatureValueSpan = document.getElementById('temperature-value');
				const saveSettingsBtn = document.getElementById('save-settings');
				const temperatureInput = document.getElementById('temperature');
				const settingsModalEl = document.getElementById('settingsModal');
				const settingsModal = new bootstrap.Modal(settingsModalEl);
				const enhancedOutputSwitch = document.getElementById('enhanced-structured-output');
				const userProfileEditor = document.getElementById('user-profile-editor');

				// Load settings from backend when modal is shown
				settingsModalEl.addEventListener('show.bs.modal', function() {
					fetch('/api/settings')
						.then(response => response.json())
						.then(config => {
							temperatureSlider.value = config.temperature;
							temperatureValueSpan.textContent = config.temperature;
							enhancedOutputSwitch.checked = config.enhanced_structured_output;
							userProfileEditor.value = config.user_profile;
						})
						.catch(error => {
							console.error('Error fetching settings:', error);
							showAlert('无法加载设置！', 'danger');
						});
				});

				// Update span when slider is moved
				temperatureSlider.addEventListener('input', function() {
					temperatureValueSpan.textContent = temperatureSlider.value;
				});

				// Save settings when button is clicked
				saveSettingsBtn.addEventListener('click', function() {
					const newTemperature = temperatureSlider.value;
					const enhancedOutput = enhancedOutputSwitch.checked;
					const userProfile = userProfileEditor.value;
					
					const settings = {
						temperature: parseFloat(newTemperature),
						'enhanced_structured_output': enhancedOutput,
						'user_profile': userProfile
					};

					fetch('/api/settings', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						},
						body: JSON.stringify(settings)
					})
					.then(response => response.json())
					.then(data => {
						console.log('Settings saved:', data);
						temperatureInput.value = newTemperature;
						settingsModal.hide();
						showAlert('设置已保存', 'success');
					})
					.catch(error => {
						console.error('Error saving settings:', error);
						showAlert('保存设置失败！', 'danger');
					});
				});

				const generateForm = document.getElementById('generate-form');
				const generateBtn = document.getElementById('generate-btn');

				let currentQuestions = [];
				let userAnswers = {};
				let eventSource = null;

				const exportMarkdownModalEl = document.getElementById('exportMarkdownModal');
				const exportMarkdownModal = new bootstrap.Modal(exportMarkdownModalEl);

				document.getElementById('export-inline-btn').addEventListener('click', () => {
					triggerMarkdownExport('inline');
				});

				document.getElementById('export-end-btn').addEventListener('click', () => {
					triggerMarkdownExport('end');
				});

				async function triggerMarkdownExport(placement) {
					exportMarkdownModal.hide();
					
					try {
						const response = await fetch('/api/export/markdown', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({
								questions: currentQuestions,
								answers_placement: placement
							})
						});

						if (!response.ok) {
							const errData = await response.json();
							throw new Error(errData.error || '导出失败');
						}

						const data = await response.json();
						downloadMarkdown(data.markdown_content, 'review-genius-exam.md');

					} catch (error) {
						console.error('Markdown export error:', error);
						alert(`导出 Markdown 出错: ${error.message}`);
					}
				}

				function downloadMarkdown(content, filename) {
					const blob = new Blob([content], { type: 'text/markdown;charset=utf-t8;' });
					const link = document.createElement("a");
					if (link.download !== undefined) { 
						const url = URL.createObjectURL(blob);
						link.setAttribute("href", url);
						link.setAttribute("download", filename);
						link.style.visibility = 'hidden';
						document.body.appendChild(link);
						link.click();
						document.body.removeChild(link);
					}
				}

				function formatQuestion(data) {
					const typeMap = {
						multiple_choice: "选择题",
						fill_in_the_blank: "填空题",
						short_answer: "简答题",
					};
					const questionTypeName = typeMap[data.question_type] || "未知题型";

					let content = `<p><strong>题型：</strong>${questionTypeName}</p>`;

					if (data.stem) {
						content += `<p><strong>题目：</strong>${data.stem.replace(
							/___/g,
							'<u style="padding: 0 1em;">&nbsp;&nbsp;&nbsp;</u>'
						)}</p>`;
					}

					if (data.question_type === "multiple_choice" && data.options) {
						content += '<p><strong>选项：</strong></p><ul class="list-group list-group-flush">';
						for (const [key, value] of Object.entries(data.options)) {
							content += `<li class="list-group-item">${key}. ${value}</li>`;
						}
						content += "</ul>";
					}
					return content;
				}

				function createQuestionCard(data, question_number) {
					const card = document.createElement('div');
					card.className = 'card mb-3 shadow-sm';
					card.style.opacity = "0";
					card.style.transform = "translateY(20px)";
					card.style.transition = "opacity 0.5s ease, transform 0.5s ease";

					let answerContent = '';
					let answerHtml = "";
					if (Array.isArray(data.answer)) {
						answerHtml = data.answer.join(", ");
					} else {
						answerHtml = data.answer;
					}

					if (answerHtml) {
						answerContent = `<p><strong>答案：</strong>${answerHtml}</p>`;
					}
					if (data.explanation) {
						answerContent += `<p><strong>解析：</strong>${data.explanation}</p>`;
					}

					card.innerHTML = `
						<div class="card-header d-flex justify-content-between align-items-center">
							<strong>题目 ${question_number}</strong>
							<span class="badge bg-secondary">${data.score}分</span>
						</div>
						<div class="card-body">
							${formatQuestion(data)}
							<button class="btn btn-info btn-sm mt-2 toggle-answer" data-bs-toggle="collapse" data-bs-target="#answer-${question_number}" aria-expanded="false" aria-controls="answer-${question_number}">
								显示答案
							</button>
							<div class="collapse" id="answer-${question_number}">
								<div class="card card-body mt-2 bg-light">
									${answerContent}
								</div>
							</div>
						</div>
						<div class="card-footer d-flex justify-content-end gap-2 bg-white">
							<button class="btn btn-outline-secondary btn-sm regenerate-btn" data-action="regenerate">
								<i class="bi bi-arrow-repeat"></i> 重新出题
							</button>
							<button class="btn btn-outline-secondary btn-sm regenerate-btn" data-action="increase_difficulty">
								<i class="bi bi-graph-up-arrow"></i> 增加难度
							</button>
							<button class="btn btn-outline-secondary btn-sm regenerate-btn" data-action="decrease_difficulty">
								<i class="bi bi-graph-down-arrow"></i> 降低难度
							</button>
						</div>
					`;
					
					card.dataset.questionIndex = question_number - 1;

					// 动态绑定重新生成按钮的事件
					card.querySelectorAll('.regenerate-btn').forEach(button => {
						button.addEventListener('click', (e) => {
							handleRegenerateClick(e.currentTarget, e.currentTarget.dataset.action);
						});
					});

					const toggleButton = card.querySelector('.toggle-answer');
					toggleButton.addEventListener('click', function() {
						this.textContent = this.textContent.includes('显示') ? '隐藏答案' : '显示答案';
					});

					setTimeout(() => {
						card.style.opacity = "1";
						card.style.transform = "translateY(0)";
					}, 10);

					return card;
				}

				function createPracticeCard(data, question_number) {
					const card = document.createElement('div');
					card.className = 'card mb-3 shadow-sm practice-card';
					card.dataset.questionIndex = question_number - 1;

					let questionContent = '';
					const typeMap = {
						multiple_choice: "选择题",
						fill_in_the_blank: "填空题",
						short_answer: "简答题",
					};
					const questionTypeName = typeMap[data.question_type] || "未知题型";

					let answerArea = '';
					if (data.question_type === 'multiple_choice') {
						answerArea += '<ul class="list-group list-group-flush">';
						for (const [key, value] of Object.entries(data.options)) {
							answerArea += `<li class="list-group-item">
								<input class="form-check-input me-1" type="radio" name="mcq-${question_number}" id="mcq-${question_number}-${key}" value="${key}">
								<label class="form-check-label" for="mcq-${question_number}-${key}">${key}. ${value}</label>
							</li>`;
						}
						answerArea += '</ul>';
					} else if (data.question_type === 'fill_in_the_blank') {
						let blank_count = 0;
						const stemWithInputs = data.stem.replace(/___/g, () => {
							blank_count++;
							return `<input type="text" class="form-control d-inline-block fitb-input" style="width: 150px; margin: 0 5px;" data-blank-index="${blank_count-1}">`;
						});
						questionContent = `<p><strong>题目：</strong>${stemWithInputs}</p>`;
					} else if (data.question_type === 'short_answer') {
						answerArea = `<textarea class="form-control" rows="5" placeholder="在此输入你的答案..."></textarea>`;
					}


					card.innerHTML = `
						<div class="card-header d-flex justify-content-between align-items-center">
							<div><strong>题目 ${question_number} (${questionTypeName})</strong></div>
							<span class="badge bg-secondary">${data.score}分</span>
						</div>
						<div class="card-body">
							${questionContent || `<p><strong>题目：</strong>${data.stem}</p>`}
							<div class="answer-area mt-3">${answerArea}</div>
							<div class="result-area mt-3" style="display: none;"></div>
						</div>
					`;
					return card;
				}

				function collectUserAnswers() {
					const userAnswers = [];
					const practiceCards = document.querySelectorAll('.practice-card');

					practiceCards.forEach((card, index) => {
						const question = currentQuestions[index];
						let answer;
						if (question.question_type === 'multiple_choice') {
							const checked = card.querySelector('input[type="radio"]:checked');
							answer = checked ? checked.value : null;
						} else if (question.question_type === 'fill_in_the_blank') {
							const inputs = card.querySelectorAll('.fitb-input');
							answer = Array.from(inputs).map(input => input.value);
						} else if (question.question_type === 'short_answer') {
							answer = card.querySelector('textarea').value;
						}
						userAnswers.push(answer);
					});
					return userAnswers;
				}

				async function submitForGrading() {
					const userAnswers = collectUserAnswers();
					const apiKey = localStorage.getItem('siliconflow_api_key');
					const temperature = localStorage.getItem('llm_temperature') || '0.7';

					// 禁用提交按钮
					const submitBtn = document.getElementById('submit-practice-btn');
					submitBtn.disabled = true;
					submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> 正在初始化批改...';
					
					document.querySelectorAll('.practice-card input, .practice-card textarea').forEach(el => el.disabled = true);

					try {
						const response = await fetch('/api/grade', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({
								questions: currentQuestions,
								answers: userAnswers,
								api_key: apiKey,
								temperature: parseFloat(temperature)
							})
						});
						
						if (!response.ok) {
							const errData = await response.json();
							throw new Error(errData.error || '批改服务连接失败');
						}
						
						submitBtn.style.display = 'none';

						const reader = response.body.getReader();
						const decoder = new TextDecoder();
						let buffer = "";
						let gradedCount = 0;

						while (true) {
							const { done, value } = await reader.read();
							if (done) break;

							buffer += decoder.decode(value, { stream: true });
							const lines = buffer.split("\n");
							buffer = lines.pop();

							for (const line of lines) {
								if (line.trim()) {
									try {
										const event = JSON.parse(line);
										const card = document.querySelector(`.practice-card[data-question-index="${event.question_index}"]`);
										if (!card) continue;
										
										const resultArea = card.querySelector('.result-area');

										if (event.type === 'error') {
											resultArea.innerHTML = `<div class="alert alert-danger p-2"><strong>错误:</strong> ${event.error}</div>`;
											resultArea.style.display = 'block';
											gradedCount++;
										} else if (event.type === 'start') {
											resultArea.innerHTML = '<pre style="white-space: pre-wrap; word-wrap: break-word; color: #6c757d;"></pre>';
											resultArea.style.display = 'block';
										} else if (event.type === 'streaming') {
											const pre = resultArea.querySelector('pre');
											if (pre) pre.textContent += event.content;
										} else if (event.type === 'end') {
											displaySingleGradingResult(resultArea, event.data, currentQuestions[event.question_index]);
											gradedCount++;
										}
									} catch (e) {
										console.error("解析或处理批改流时出错:", e);
									}
								}
							}
						}
						
						if (gradedCount === currentQuestions.length) {
							displayOverallScore();
						}

					} catch(error) {
						alert(`提交批改时出错: ${error.message}`);
						submitBtn.style.display = 'block';
						submitBtn.disabled = false;
						submitBtn.textContent = '提交批改';
						document.querySelectorAll('.practice-card input, .practice-card textarea').forEach(el => el.disabled = false);
					}
				}

				function displaySingleGradingResult(resultArea, resultData, questionData) {
					const scoreColor = resultData.score === questionData.score ? 'text-success' : (resultData.score > 0 ? 'text-warning' : 'text-danger');
					let resultHtml = `
						<h5>批改结果</h5>
						<p><strong>得分: <span class="${scoreColor}">${resultData.score}</span> / ${questionData.score}</strong></p>
					`;

					if (questionData.question_type === 'multiple_choice') {
						resultHtml += `<p><strong>正确答案:</strong> ${questionData.answer}</p>`;
					} else {
						resultHtml += `<p><strong>参考答案:</strong> ${Array.isArray(questionData.answer) ? questionData.answer.join(', ') : questionData.answer}</p>`;
					}

					resultHtml += `<p><strong>AI点评:</strong> ${resultData.feedback}</p>`;
					resultArea.innerHTML = resultHtml;
				}
				
				function displayOverallScore() {
					let totalScore = 0;
					let earnedScore = 0;

					document.querySelectorAll('.practice-card').forEach((card, index) => {
						const question = currentQuestions[index];
						totalScore += question.score;
						const scoreSpan = card.querySelector('.result-area span[class*="text-"]');
						if (scoreSpan) {
							earnedScore += parseInt(scoreSpan.textContent, 10) || 0;
						}
					});

					const overallResult = document.createElement('div');
					overallResult.className = 'alert alert-info mt-4';
					overallResult.innerHTML = `<h4>练习完成！</h4><p class="mb-0"><strong>总得分: ${earnedScore} / ${totalScore}</strong></p>`;
					document.getElementById('questions-container').appendChild(overallResult);
				}

				function addReviewControls() {
					const controlsContainer = document.getElementById("controls-container");
					controlsContainer.innerHTML = ''; // 清空现有控件

					const buttonGroup = document.createElement('div');
					buttonGroup.className = 'mt-4 d-grid gap-2 d-md-flex justify-content-md-center';

					const startBtn = document.createElement('button');
					startBtn.id = 'start-practice-btn';
					startBtn.className = 'btn btn-primary btn-lg';
					startBtn.textContent = '开始在线练习';
					startBtn.addEventListener('click', showPracticePage);
					buttonGroup.appendChild(startBtn);

					const exportBtn = document.createElement('button');
					exportBtn.id = 'export-md-btn';
					exportBtn.className = 'btn btn-secondary btn-lg';
					exportBtn.textContent = '导出为 Markdown';
					exportBtn.setAttribute('data-bs-toggle', 'modal');
					exportBtn.setAttribute('data-bs-target', '#exportMarkdownModal');
					buttonGroup.appendChild(exportBtn);

					controlsContainer.appendChild(buttonGroup);
				}

				function showReviewPage() {
					const formContainer = document.querySelector(".col-md-4");
					// 在从练习页面返回时，它将是 col-md-12
					const questionsCol = document.querySelector(".col-md-12"); 
					const questionsContainer = document.getElementById("questions-container");
					const controlsContainer = document.getElementById("controls-container");

					formContainer.style.display = "block";
					if (questionsCol) {
						questionsCol.classList.replace("col-md-12", "col-md-8");
					}
					
					questionsContainer.innerHTML = "";
					controlsContainer.innerHTML = "";

					const title = document.createElement("h4");
					title.textContent = "生成的题目";
					questionsContainer.appendChild(title);

					currentQuestions.forEach((q, index) => {
						const card = createQuestionCard(q, index + 1);
						questionsContainer.appendChild(card);
					});

					addReviewControls(); // 添加"开始练习"按钮
				}

				function showPracticePage() {
					const formContainer = document.querySelector(".col-md-4");
					const questionsCol = document.querySelector(".col-md-8");
					const questionsContainer = document.getElementById("questions-container");
					const controlsContainer = document.getElementById("controls-container");

					formContainer.style.display = "none"; // 隐藏表单
					questionsContainer.innerHTML = ""; // 清空题目预览
					controlsContainer.innerHTML = ""; // 清空"开始练习"按钮

					questionsCol.classList.replace("col-md-8", "col-md-12"); // 扩展宽度

					const practiceTitle = document.createElement("h4");
					practiceTitle.textContent = "在线练习";
					questionsContainer.appendChild(practiceTitle);


					currentQuestions.forEach((q, index) => {
						const card = createPracticeCard(q, index + 1);
						questionsContainer.appendChild(card);
					});

					const buttonGroup = document.createElement('div');
					buttonGroup.className = 'mt-4 text-center';

					const submitBtn = document.createElement('button');
					submitBtn.id = 'submit-practice-btn';
					submitBtn.className = 'btn btn-success btn-lg me-2';
					submitBtn.textContent = '提交批改';
					submitBtn.addEventListener('click', submitForGrading);
					buttonGroup.appendChild(submitBtn);

					const backBtn = document.createElement('button');
					backBtn.id = 'back-to-review-btn';
					backBtn.className = 'btn btn-secondary btn-lg';
					backBtn.textContent = '返回预览';
					backBtn.addEventListener('click', showReviewPage);
					buttonGroup.appendChild(backBtn);

					questionsContainer.appendChild(buttonGroup);
				}

				document
					.getElementById("generate-form")
					.addEventListener("submit", async function (event) {
						event.preventDefault();

						const generateBtn = document.getElementById("generate-btn");
						const spinner = generateBtn.querySelector(".spinner-border");
						const questionsContainer = document.getElementById("questions-container");
						const placeholder = document.getElementById("start-generation-placeholder");
						const controlsContainer = document.getElementById("controls-container");

						generateBtn.disabled = true;
						spinner.classList.remove("d-none");
						if (placeholder) {
							placeholder.remove();
						}
						questionsContainer.innerHTML = '<p class="text-center text-primary">正在连接模型，请稍候...</p>';
						controlsContainer.innerHTML = '';

						const formData = new FormData(this);

						try {
							const response = await fetch("/api/process", {
								method: "POST",
								body: formData,
							});

							if (!response.ok) {
								const errorData = await response.json();
								throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
							}

							questionsContainer.innerHTML = ""; // 清空等待提示
							currentQuestions = []; // 重置题目

							const reader = response.body.getReader();
							const decoder = new TextDecoder();
							let buffer = "";
							let questionCounter = 1;
							let currentCard = null;
							let currentCardBody = null;

							while (true) {
								const { done, value } = await reader.read();
								if (done) break;

								buffer += decoder.decode(value, { stream: true });
								const lines = buffer.split("\n");
								buffer = lines.pop();

								for (const line of lines) {
									if (line.trim()) {
										const event = JSON.parse(line);
										if (event.type === 'error') {
											let errorMessage = event.error || '一个未知的流错误发生了';
											if (event.error_type === 'security') {
												errorMessage = `内容安全检查未通过：${event.error}`;
											} else if (event.error_type === 'authentication') {
												errorMessage = `API Key 认证失败：${event.error}`;
											}
											throw new Error(errorMessage);
										}
										
										if (event.type === 'start') {
											const cardId = `question-card-${questionCounter}`;
											const cardWrapper = document.createElement("div");
											cardWrapper.innerHTML = `
												<div id="${cardId}" class="card mb-3 shadow-sm">
													<div class="card-header">
														<strong>题目 ${questionCounter}</strong>
													</div>
													<div class="card-body">
														<pre style="white-space: pre-wrap; word-wrap: break-word;"></pre>
													</div>
												</div>
											`;
											currentCard = cardWrapper.firstElementChild;
											questionsContainer.appendChild(currentCard);
											currentCardBody = currentCard.querySelector('.card-body pre');

										} else if (event.type === 'streaming' && currentCardBody) {
											currentCardBody.textContent += event.content;
											questionsContainer.scrollTop = questionsContainer.scrollHeight;

										} else if (event.type === 'end' && currentCard) {
											const finalData = event.data;
											currentQuestions.push(finalData); 
											const finalCard = createQuestionCard(finalData, questionCounter);
											currentCard.replaceWith(finalCard);
											
											questionCounter++;
											currentCard = null; 
											currentCardBody = null;
										}
									}
								}
							}
							
							if (currentQuestions.length > 0) {
								addReviewControls();
							}

						} catch (error) {
							alert(`出题失败: ${error.message}`);
							questionsContainer.innerHTML = `<div class="alert alert-danger" role="alert"><strong>出错了:</strong> ${error.message}</div>`;
						} finally {
							generateBtn.disabled = false;
							spinner.classList.add("d-none");
						}
					});

				function showAlert(message, type = 'info') {
					const alertContainer = document.getElementById('alert-container');
					if (!alertContainer) return;

					// Map custom types to bootstrap alert types
					const alertType = type === 'error' ? 'danger' : type;

					const wrapper = document.createElement('div');
					wrapper.innerHTML = [
						`<div class="alert alert-${alertType} alert-dismissible fade show" role="alert">`,
						`   <div>${message}</div>`,
						'   <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>',
						'</div>'
					].join('');

					alertContainer.append(wrapper);

					// Automatically remove the alert after 5 seconds
					setTimeout(() => {
						const alert = wrapper.querySelector('.alert');
						if (alert) {
							bootstrap.Alert.getOrCreateInstance(alert).close();
						}
					}, 5000);
				}

				async function handleRegenerateClick(button, action) {
					const card = button.closest('.card');
					const questionIndex = parseInt(card.dataset.questionIndex, 10);
					const originalQuestion = currentQuestions[questionIndex];
					
					const apiKey = localStorage.getItem('siliconflow_api_key');
					if (!apiKey) {
						alert('请输入API Key');
						return;
					}

					const userRequirement = document.getElementById('user_input').value || '无特定要求';
					
					// 找到要被替换的原始卡片
					const originalCard = document.querySelector(`.card[data-question-index='${questionIndex}']`);
					if (!originalCard) return;


					// 1. 直接创建骨架卡片
					const skeletonCard = document.createElement('div');
					skeletonCard.className = 'card mb-3 shadow-sm';
					skeletonCard.dataset.questionIndex = questionIndex;
					skeletonCard.innerHTML = `
						<div class="card-header">
							<strong>题目 ${questionIndex + 1} (正在重新生成...)</strong>
						</div>
						<div class="card-body">
							<pre style="white-space: pre-wrap; word-wrap: break-word; color: #6c757d;"></pre>
						</div>
					`;

					// 2. 立即替换原始卡片
					originalCard.replaceWith(skeletonCard);
					const preElement = skeletonCard.querySelector('pre');

					try {
						// 3. 开始请求
						const response = await fetch('/api/regenerate_question', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({
								question: originalQuestion,
								action: action,
								user_requirement: userRequirement,
								api_key: apiKey
							})
						});

						if (!response.ok) {
							const errorData = await response.json();
							throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
						}
						
						const reader = response.body.getReader();
						const decoder = new TextDecoder();
						let buffer = "";
						
						// 清空 pre 标签的初始内容
						if(preElement) preElement.textContent = '';

						while (true) {
							const { done, value } = await reader.read();
							if (done) break;

							buffer += decoder.decode(value, { stream: true });
							const lines = buffer.split("\n");
							buffer = lines.pop();

							for (const line of lines) {
								if (line.trim()) {
									// JSON.parse可能会抛出异常，如果流数据不完整
									try {
										const event = JSON.parse(line);
										if (event.type === 'error') throw new Error(event.error || '流处理错误');
										
										if (event.type === 'streaming' && preElement) {
											preElement.textContent += event.content;
										} else if (event.type === 'end') {
											const newQuestionData = event.data;
											const newCard = createQuestionCard(newQuestionData, questionIndex + 1);
											
											// 最终替换骨架卡片
											const cardToReplace = document.querySelector(`.card[data-question-index='${questionIndex}']`);
											if(cardToReplace) cardToReplace.replaceWith(newCard);
											
											// 更新全局题目列表
											currentQuestions[questionIndex] = newQuestionData;
										}
									} catch(e) {
										// 忽略JSON解析错误，等待更多数据
										console.warn("JSON parsing error in stream, waiting for more data...", line);
									}
								}
							}
						}
					} catch (error) {
						alert(`操作失败: ${error.message}`);
						// 出错时，恢复为原始卡片
						const finalCard = createQuestionCard(originalQuestion, questionIndex + 1);
						const cardToReplace = document.querySelector(`.card[data-question-index='${questionIndex}']`);
						if(cardToReplace) cardToReplace.replaceWith(finalCard);
					}
				}
			});
		</script>
	</body>
</html>


