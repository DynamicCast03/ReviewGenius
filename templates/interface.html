<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>ReviewGenius - æ™ºèƒ½å‡ºé¢˜</title>
		<link
			href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
			rel="stylesheet"
		/>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
		<style>
			body {
				background-color: #f8f9fa;
			}
			.container {
				max-width: 1200px;
			}
			.card-header strong {
				font-size: 1.1rem;
			}
		</style>
	</head>
	<body>
		<div id="alert-container" class="position-fixed top-0 start-50 translate-middle-x p-3" style="z-index: 1056; width: fit-content;">
			<!-- Dynamic alerts will be injected here -->
		</div>
		<div class="container mt-5">
			<div class="text-center mb-5 d-flex justify-content-center align-items-center">
				<h1 class="me-3">ReviewGenius æ™ºèƒ½å‡ºé¢˜ç³»ç»Ÿ</h1>
				<button type="button" class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#settingsModal">
					<i class="bi bi-gear"></i>
				</button>
			</div>

			<div class="row g-5">
				<div class="col-md-4">
					<form id="generate-form">
						<input type="hidden" id="temperature" name="temperature" value="1.0">
						<div class="mb-3">
							<label class="form-label fw-bold">1. ç®¡ç†å‚è€ƒèµ„æ–™</label>
							<div id="file-management-area">
								<ul class="list-group mb-2" id="file-list">
									<!-- æ–‡ä»¶åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€åŠ è½½ -->
								</ul>
								<div class="input-group">
									<input type="file" class="form-control" id="new-file-upload" multiple>
									<button class="btn btn-outline-secondary" type="button" id="upload-btn">
										<span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
										ä¸Šä¼ 
									</button>
								</div>
							</div>
						</div>
						<div class="mb-3">
							<label for="api_key" class="form-label fw-bold"
								>2. è¾“å…¥API Key</label
							>
							<input
								type="password"
								class="form-control"
								id="api_key"
								name="api_key"
								placeholder="è¯·è¾“å…¥ SiliconFlow API Key"
								required
							/>
						</div>
						<div class="mb-3">
							<label for="user_input" class="form-label fw-bold"
								>3. è¾“å…¥é¢å¤–è¦æ±‚ (å¯é€‰)</label
							>
							<textarea
								class="form-control"
								id="user_input"
								name="user_input"
								rows="3"
								placeholder="ä¾‹å¦‚ï¼šè¯·ä¾§é‡äºXXç« èŠ‚çš„çŸ¥è¯†ç‚¹"
							></textarea>
						</div>
						<div class="mb-4">
							<label class="form-label fw-bold">4. è®¾ç½®é¢˜å‹å’Œæ•°é‡</label>
							<div class="row g-2 mb-2">
								<div class="col">
									<label for="choice_count" class="form-label"
										>é€‰æ‹©é¢˜</label
									>
									<input
										type="number"
										class="form-control"
										id="choice_count"
										name="choice_count"
										value="0"
										min="0"
									/>
								</div>
								<div class="col">
									<label for="blank_count" class="form-label"
										>å¡«ç©ºé¢˜</label
									>
									<input
										type="number"
										class="form-control"
										id="blank_count"
										name="blank_count"
										value="0"
										min="0"
									/>
								</div>
								<div class="col">
									<label for="short_count" class="form-label"
										>ç®€ç­”/è®¡ç®—é¢˜</label
									>
									<input
										type="number"
										class="form-control"
										id="short_count"
										name="short_count"
										value="1"
										min="0"
									/>
								</div>
							</div>
							<div class="row g-2">
								<div class="col">
									<label for="choice_score" class="form-label">åˆ†å€¼</label>
									<input type="number" class="form-control" id="choice_score" name="choice_score" value="5" min="1">
								</div>
								<div class="col">
									<label for="blank_score" class="form-label">åˆ†å€¼</label>
									<input type="number" class="form-control" id="blank_score" name="blank_score" value="5" min="1">
								</div>
								<div class="col">
									<label for="short_score" class="form-label">åˆ†å€¼</label>
									<input type="number" class="form-control" id="short_score" name="short_score" value="10" min="1">
								</div>
							</div>
						</div>
						<button
							type="submit"
							class="btn btn-primary w-100 btn-lg"
							id="generate-btn"
						>
							<span
								class="spinner-border spinner-border-sm d-none"
								role="status"
								aria-hidden="true"
							></span>
							ç”Ÿæˆè¯•å·
						</button>
					</form>
				</div>

				<div class="col-md-8">
					<h4>ç”Ÿæˆçš„é¢˜ç›®</h4>
					<div
						id="questions-container"
						class="mt-3"
						style="min-height: 400px"
					>
						<!-- æµå¼ç”Ÿæˆçš„å¡ç‰‡å°†å‡ºç°åœ¨è¿™é‡Œ -->
						<div
							class="alert alert-secondary text-center"
							id="start-generation-placeholder"
						>
							ç‚¹å‡»"ç”Ÿæˆè¯•å·"å¼€å§‹å‡ºé¢˜
						</div>
					</div>
					<div id="controls-container" class="mt-3 text-center"></div>
				</div>
			</div>
		</div>

		<!-- Export Options Modal -->
		<div class="modal fade" id="exportMarkdownModal" tabindex="-1" aria-labelledby="exportMarkdownModalLabel" aria-hidden="true">
			<div class="modal-dialog modal-dialog-centered">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title" id="exportMarkdownModalLabel">é€‰æ‹©å¯¼å‡ºé€‰é¡¹</h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
						<p>è¯·é€‰æ‹©ç­”æ¡ˆåœ¨ Markdown æ–‡ä»¶ä¸­çš„ä½ç½®ï¼š</p>
						<div class="d-grid gap-2">
							<button type="button" class="btn btn-outline-primary" id="export-inline-btn">ç­”æ¡ˆç´§è·Ÿåœ¨æ¯é“é¢˜åé¢</button>
							<button type="button" class="btn btn-outline-primary" id="export-end-btn">æ‰€æœ‰ç­”æ¡ˆé›†ä¸­åœ¨æ–‡æ¡£æœ«å°¾</button>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Settings Modal -->
		<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
			<div class="modal-dialog modal-lg modal-dialog-centered">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title" id="settingsModalLabel"><i class="bi bi-gear-wide-connected"></i> é«˜çº§è®¾ç½®</h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
						<!-- æ¨¡å‹è®¾ç½® -->
						<fieldset class="mb-4 p-3 border rounded-3">
							<legend class="fw-bold fs-6 w-auto px-2">ğŸ¤– æ¨¡å‹è®¾ç½®</legend>
							<div class="form-group mb-4">
								<div class="d-flex justify-content-between align-items-center">
									<label for="temperature-slider" class="form-label mb-0">æ¨¡å‹æ¸©åº¦ (Temperature)</label>
									<span id="temperature-value" class="badge bg-primary rounded-pill">1.0</span>
								</div>
								<input type="range" class="form-range" id="temperature-slider" min="0" max="2" step="0.1" value="1.0">
								<small class="form-text text-muted">å€¼è¶Šé«˜ï¼Œå›ç­”è¶Šéšæœºå’Œæœ‰åˆ›é€ æ€§ï¼›å€¼è¶Šä½ï¼Œå›ç­”è¶Šç¡®å®šå’Œä¿å®ˆã€‚</small>
							</div>
			
							<div class="form-check form-switch">
								<input class="form-check-input" type="checkbox" id="enhanced-structured-output">
								<label class="form-check-label" for="enhanced-structured-output">
									å¢å¼ºç»“æ„åŒ–è¾“å‡º
								</label>
								<small class="form-text text-muted d-block">å¼€å¯åï¼Œå°†é¢å¤–è°ƒç”¨æ¨¡å‹è¿›è¡Œæ ¼å¼æ£€æŸ¥ï¼Œè¿”å›æ›´ç¨³å®šçš„JSONæ•°æ®ã€‚è¿™å¯èƒ½ä¼šå¢åŠ é¦–ä¸ªtokençš„ç­‰å¾…æ—¶é—´ã€‚</small>
							</div>
						</fieldset>
			
						<!-- ç”¨æˆ·ç”»åƒ -->
						<fieldset class="mb-3 p-3 border rounded-3">
							<legend class="fw-bold fs-6 w-auto px-2">ğŸ‘¤ ä¸ªæ€§åŒ–</legend>
							<div class="form-check form-switch mb-3">
								<input class="form-check-input" type="checkbox" id="user-profile-enabled">
								<label class="form-check-label" for="user-profile-enabled">å¯ç”¨ç”¨æˆ·ç”»åƒåŠŸèƒ½</label>								<small class="form-text text-muted d-block">å¯ç”¨åï¼Œç³»ç»Ÿå°†æ ¹æ®æ‚¨çš„ç­”é¢˜å†å²ç”Ÿæˆå’Œä½¿ç”¨ç”¨æˆ·ç”»åƒï¼Œä»¥æä¾›æ›´ä¸ªæ€§åŒ–çš„å‡ºé¢˜å’Œè¯„åˆ†ã€‚</small>
							</div>
							<div class="form-group">
								<label for="user-profile-editor" class="form-label">ç”¨æˆ·ç”»åƒå†…å®¹</label>
								<textarea class="form-control" id="user-profile-editor" rows="6" placeholder="ç”¨æˆ·ç”»åƒå°†åœ¨è¿™é‡Œæ˜¾ç¤ºå’Œç¼–è¾‘..."></textarea>
								<small class="form-text text-muted">æ­¤ç”»åƒå°†å½±å“æœªæ¥çš„å‡ºé¢˜å’Œè¯„åˆ†ã€‚</small>
							</div>
						</fieldset>
					</div>
					<div class="modal-footer">
						<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">å…³é—­</button>
						<button type="button" class="btn btn-primary" id="save-settings">ä¿å­˜è®¾ç½®</button>
					</div>
				</div>
			</div>
		</div>

		<div style="height: 80vh;"></div> <!-- å¢åŠ ç©ºç™½ï¼Œä½¿å¾—é¡µé¢å¯ä»¥å‘ä¸‹æ»šåŠ¨ -->

		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
		<!-- å¼•å…¥ Socket.IO å®¢æˆ·ç«¯åº“ -->
		<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
		<script>
			document.addEventListener('DOMContentLoaded', function() {
				// API Keyè®°å¿†åŠŸèƒ½
				const apiKeyInput = document.getElementById('api_key');
				const savedApiKey = localStorage.getItem('siliconflow_api_key');
				if (savedApiKey) {
					apiKeyInput.value = savedApiKey;
				}

				apiKeyInput.addEventListener('input', function() {
					localStorage.setItem('siliconflow_api_key', apiKeyInput.value);
				});

				// === æ–‡ä»¶ç®¡ç†é€»è¾‘ START ===
				const fileList = document.getElementById('file-list');
				const newFileUpload = document.getElementById('new-file-upload');
				const uploadBtn = document.getElementById('upload-btn');
				const uploadBtnSpinner = uploadBtn.querySelector('.spinner-border');
				const uploadBtnText = uploadBtn.lastChild;

				function renderFileList(files) {
					fileList.innerHTML = ''; // æ¸…ç©ºç°æœ‰åˆ—è¡¨
					if (!files || files.length === 0) {
						fileList.innerHTML = '<li class="list-group-item text-muted small">å°šæœªä¸Šä¼ ä»»ä½•å‚è€ƒèµ„æ–™</li>';
					} else {
						files.forEach(filename => {
							const li = document.createElement('li');
							li.className = 'list-group-item d-flex justify-content-between align-items-center';
							
							const fileNameSpan = document.createElement('span');
							fileNameSpan.textContent = filename;
							fileNameSpan.style.wordBreak = 'break-all';

							const deleteBtn = document.createElement('button');
							deleteBtn.className = 'btn btn-danger btn-sm';
							deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
							deleteBtn.type = 'button';
							deleteBtn.onclick = () => deleteFile(filename);

							li.appendChild(fileNameSpan);
							li.appendChild(deleteBtn);
							fileList.appendChild(li);
						});
					}
				}

				// WebSocket è¿æ¥
				const socket = io();

				socket.on('connect', function() {
					console.log('æˆåŠŸè¿æ¥åˆ°æœåŠ¡å™¨!');
				});

				socket.on('file_list_update', function(data) {
					console.log('æ”¶åˆ°æ–‡ä»¶åˆ—è¡¨æ›´æ–°:', data.files);
					renderFileList(data.files);
				});

				socket.on('disconnect', function() {
					console.log('ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥ã€‚');
				});

				async function uploadFiles() {
					const files = newFileUpload.files;
					if (files.length === 0) {
						showAlert('è¯·å…ˆé€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶', 'warning');
						return;
					}

					uploadBtn.disabled = true;
					uploadBtnSpinner.classList.remove('d-none');
					uploadBtnText.textContent = ' ä¸Šä¼ ä¸­...';

					const formData = new FormData();
					for (const file of files) {
						formData.append('files', file);
					}

					try {
						const response = await fetch('/api/upload', {
							method: 'POST',
							body: formData
						});
						const result = await response.json();
						if (!response.ok) {
							let errorMsg = result.message || 'ä¸Šä¼ å¤±è´¥';
							if (result.errors) {
								errorMsg += ': ' + Object.entries(result.errors).map(([k, v]) => `${k} (${v})`).join(', ');
							}
							throw new Error(errorMsg);
						}
						
						if (result.uploaded_files && result.uploaded_files.length > 0) {
							showAlert(`${result.uploaded_files.join(', ')} ä¸Šä¼ æˆåŠŸ`, 'success');
						} else if (response.status === 200) {
							showAlert(result.message || 'ä¸Šä¼ æˆåŠŸ', 'success');
						}
						
						newFileUpload.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©æ¡†
						// UIæ›´æ–°å°†ç”±WebSocketäº‹ä»¶å¤„ç†
					} catch (error) {
						console.error('Upload error:', error);
						showAlert(`ä¸Šä¼ å‡ºé”™: ${error.message}`, 'danger');
					} finally {
						uploadBtn.disabled = false;
						uploadBtnSpinner.classList.add('d-none');
						uploadBtnText.textContent = 'ä¸Šä¼ ';
					}
				}

				async function deleteFile(filename) {
					if (!confirm(`ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ "${filename}" å—ï¼Ÿ`)) {
						return;
					}
					try {
						const response = await fetch(`/api/files/${encodeURIComponent(filename)}`, {
							method: 'DELETE'
						});
						const result = await response.json();
						if (!response.ok) {
							throw new Error(result.error || 'åˆ é™¤å¤±è´¥');
						}
						showAlert(result.message, 'success');
						// UIæ›´æ–°å°†ç”±WebSocketäº‹ä»¶å¤„ç†
					} catch (error) {
						console.error('Delete error:', error);
						showAlert(`åˆ é™¤æ–‡ä»¶å¤±è´¥: ${error.message}`, 'danger');
					}
				}

				// ç»‘å®šäº‹ä»¶
				uploadBtn.addEventListener('click', uploadFiles);

				// === æ–‡ä»¶ç®¡ç†é€»è¾‘ END ===

				// Settings Modal Logic
				const temperatureSlider = document.getElementById('temperature-slider');
				const temperatureValueSpan = document.getElementById('temperature-value');
				const saveSettingsBtn = document.getElementById('save-settings');
				const temperatureInput = document.getElementById('temperature');
				const settingsModalEl = document.getElementById('settingsModal');
				const settingsModal = new bootstrap.Modal(settingsModalEl);
				const enhancedOutputSwitch = document.getElementById('enhanced-structured-output');
				const userProfileEditor = document.getElementById('user-profile-editor');
				const userProfileEnabledSwitch = document.getElementById('user-profile-enabled');

				// Load settings from backend when modal is shown
				settingsModalEl.addEventListener('show.bs.modal', function() {
					fetch('/api/settings')
						.then(response => response.json())
						.then(config => {
							temperatureSlider.value = config.temperature;
							temperatureValueSpan.textContent = config.temperature;
							enhancedOutputSwitch.checked = config.enhanced_structured_output;
							userProfileEnabledSwitch.checked = config.user_profile_enabled;
							userProfileEditor.value = config.user_profile;

							// æ ¹æ®å¼€å…³çŠ¶æ€å†³å®šç¼–è¾‘å™¨æ˜¯å¦å¯ç”¨
							userProfileEditor.disabled = !config.user_profile_enabled;
						})
						.catch(error => {
							console.error('Error fetching settings:', error);
							showAlert('æ— æ³•åŠ è½½è®¾ç½®ï¼', 'danger');
						});
				});

				// æ ¹æ®å¼€å…³çŠ¶æ€åŠ¨æ€ç¦ç”¨/å¯ç”¨ç¼–è¾‘å™¨
				userProfileEnabledSwitch.addEventListener('change', function() {
					userProfileEditor.disabled = !this.checked;
				});

				// Update span when slider is moved
				temperatureSlider.addEventListener('input', function() {
					temperatureValueSpan.textContent = temperatureSlider.value;
				});

				// Save settings when button is clicked
				saveSettingsBtn.addEventListener('click', function() {
					const newTemperature = temperatureSlider.value;
					const enhancedOutput = enhancedOutputSwitch.checked;
					const userProfile = userProfileEditor.value;
					const userProfileEnabled = userProfileEnabledSwitch.checked;
					
					const settings = {
						temperature: parseFloat(newTemperature),
						'enhanced_structured_output': enhancedOutput,
						'user_profile_enabled': userProfileEnabled,
						'user_profile': userProfile
					};

					fetch('/api/settings', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						},
						body: JSON.stringify(settings)
					})
					.then(response => response.json())
					.then(data => {
						console.log('Settings saved:', data);
						temperatureInput.value = newTemperature;
						settingsModal.hide();
						showAlert('è®¾ç½®å·²ä¿å­˜', 'success');
					})
					.catch(error => {
						console.error('Error saving settings:', error);
						showAlert('ä¿å­˜è®¾ç½®å¤±è´¥ï¼', 'danger');
					});
				});

				const generateForm = document.getElementById('generate-form');
				const generateBtn = document.getElementById('generate-btn');

				let currentQuestions = [];
				let userAnswers = {};
				let eventSource = null;

				const exportMarkdownModalEl = document.getElementById('exportMarkdownModal');
				const exportMarkdownModal = new bootstrap.Modal(exportMarkdownModalEl);

				document.getElementById('export-inline-btn').addEventListener('click', () => {
					triggerMarkdownExport('inline');
				});

				document.getElementById('export-end-btn').addEventListener('click', () => {
					triggerMarkdownExport('end');
				});

				async function triggerMarkdownExport(placement) {
					exportMarkdownModal.hide();
					
					try {
						const response = await fetch('/api/export/markdown', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({
								questions: currentQuestions,
								answers_placement: placement
							})
						});

						if (!response.ok) {
							const errData = await response.json();
							throw new Error(errData.error || 'å¯¼å‡ºå¤±è´¥');
						}

						const data = await response.json();
						downloadMarkdown(data.markdown_content, 'review-genius-exam.md');

					} catch (error) {
						console.error('Markdown export error:', error);
						alert(`å¯¼å‡º Markdown å‡ºé”™: ${error.message}`);
					}
				}

				function downloadMarkdown(content, filename) {
					const blob = new Blob([content], { type: 'text/markdown;charset=utf-t8;' });
					const link = document.createElement("a");
					if (link.download !== undefined) { 
						const url = URL.createObjectURL(blob);
						link.setAttribute("href", url);
						link.setAttribute("download", filename);
						link.style.visibility = 'hidden';
						document.body.appendChild(link);
						link.click();
						document.body.removeChild(link);
					}
				}

				function formatQuestion(data) {
					const typeMap = {
						multiple_choice: "é€‰æ‹©é¢˜",
						fill_in_the_blank: "å¡«ç©ºé¢˜",
						short_answer: "ç®€ç­”é¢˜",
					};
					const questionTypeName = typeMap[data.question_type] || "æœªçŸ¥é¢˜å‹";

					let content = `<p><strong>é¢˜å‹ï¼š</strong>${questionTypeName}</p>`;

					if (data.stem) {
						content += `<p><strong>é¢˜ç›®ï¼š</strong>${data.stem.replace(
							/___/g,
							'<u style="padding: 0 1em;">&nbsp;&nbsp;&nbsp;</u>'
						)}</p>`;
					}

					if (data.question_type === "multiple_choice" && data.options) {
						content += '<p><strong>é€‰é¡¹ï¼š</strong></p><ul class="list-group list-group-flush">';
						for (const [key, value] of Object.entries(data.options)) {
							content += `<li class="list-group-item">${key}. ${value}</li>`;
						}
						content += "</ul>";
					}
					return content;
				}

				function createQuestionCard(data, question_number) {
					const card = document.createElement('div');
					card.className = 'card mb-3 shadow-sm';
					card.style.opacity = "0";
					card.style.transform = "translateY(20px)";
					card.style.transition = "opacity 0.5s ease, transform 0.5s ease";

					let answerContent = '';
					let answerHtml = "";
					if (Array.isArray(data.answer)) {
						answerHtml = data.answer.join(", ");
					} else {
						answerHtml = data.answer;
					}

					if (answerHtml) {
						answerContent = `<p><strong>ç­”æ¡ˆï¼š</strong>${answerHtml}</p>`;
					}
					if (data.explanation) {
						answerContent += `<p><strong>è§£æï¼š</strong>${data.explanation}</p>`;
					}

					card.innerHTML = `
						<div class="card-header d-flex justify-content-between align-items-center">
							<strong>é¢˜ç›® ${question_number}</strong>
							<span class="badge bg-secondary">${data.score}åˆ†</span>
						</div>
						<div class="card-body">
							${formatQuestion(data)}
							<button class="btn btn-info btn-sm mt-2 toggle-answer" data-bs-toggle="collapse" data-bs-target="#answer-${question_number}" aria-expanded="false" aria-controls="answer-${question_number}">
								æ˜¾ç¤ºç­”æ¡ˆ
							</button>
							<div class="collapse" id="answer-${question_number}">
								<div class="card card-body mt-2 bg-light">
									${answerContent}
								</div>
							</div>
						</div>
						<div class="card-footer d-flex justify-content-end gap-2 bg-white">
							<button class="btn btn-outline-secondary btn-sm regenerate-btn" data-action="regenerate">
								<i class="bi bi-arrow-repeat"></i> é‡æ–°å‡ºé¢˜
							</button>
							<button class="btn btn-outline-secondary btn-sm regenerate-btn" data-action="increase_difficulty">
								<i class="bi bi-graph-up-arrow"></i> å¢åŠ éš¾åº¦
							</button>
							<button class="btn btn-outline-secondary btn-sm regenerate-btn" data-action="decrease_difficulty">
								<i class="bi bi-graph-down-arrow"></i> é™ä½éš¾åº¦
							</button>
						</div>
					`;
					
					card.dataset.questionIndex = question_number - 1;

					// åŠ¨æ€ç»‘å®šé‡æ–°ç”ŸæˆæŒ‰é’®çš„äº‹ä»¶
					card.querySelectorAll('.regenerate-btn').forEach(button => {
						button.addEventListener('click', (e) => {
							handleRegenerateClick(e.currentTarget, e.currentTarget.dataset.action);
						});
					});

					const toggleButton = card.querySelector('.toggle-answer');
					toggleButton.addEventListener('click', function() {
						this.textContent = this.textContent.includes('æ˜¾ç¤º') ? 'éšè—ç­”æ¡ˆ' : 'æ˜¾ç¤ºç­”æ¡ˆ';
					});

					setTimeout(() => {
						card.style.opacity = "1";
						card.style.transform = "translateY(0)";
					}, 10);

					return card;
				}

				function createPracticeCard(data, question_number) {
					const card = document.createElement('div');
					card.className = 'card mb-3 shadow-sm practice-card';
					card.dataset.questionIndex = question_number - 1;

					let questionContent = '';
					const typeMap = {
						multiple_choice: "é€‰æ‹©é¢˜",
						fill_in_the_blank: "å¡«ç©ºé¢˜",
						short_answer: "ç®€ç­”é¢˜",
					};
					const questionTypeName = typeMap[data.question_type] || "æœªçŸ¥é¢˜å‹";

					let answerArea = '';
					if (data.question_type === 'multiple_choice') {
						answerArea += '<ul class="list-group list-group-flush">';
						for (const [key, value] of Object.entries(data.options)) {
							answerArea += `<li class="list-group-item">
								<input class="form-check-input me-1" type="radio" name="mcq-${question_number}" id="mcq-${question_number}-${key}" value="${key}">
								<label class="form-check-label" for="mcq-${question_number}-${key}">${key}. ${value}</label>
							</li>`;
						}
						answerArea += '</ul>';
					} else if (data.question_type === 'fill_in_the_blank') {
						let blank_count = 0;
						const stemWithInputs = data.stem.replace(/___/g, () => {
							blank_count++;
							return `<input type="text" class="form-control d-inline-block fitb-input" style="width: 150px; margin: 0 5px;" data-blank-index="${blank_count-1}">`;
						});
						questionContent = `<p><strong>é¢˜ç›®ï¼š</strong>${stemWithInputs}</p>`;
					} else if (data.question_type === 'short_answer') {
						answerArea = `<textarea class="form-control" rows="5" placeholder="åœ¨æ­¤è¾“å…¥ä½ çš„ç­”æ¡ˆ..."></textarea>`;
					}


					card.innerHTML = `
						<div class="card-header d-flex justify-content-between align-items-center">
							<div><strong>é¢˜ç›® ${question_number} (${questionTypeName})</strong></div>
							<span class="badge bg-secondary">${data.score}åˆ†</span>
						</div>
						<div class="card-body">
							${questionContent || `<p><strong>é¢˜ç›®ï¼š</strong>${data.stem}</p>`}
							<div class="answer-area mt-3">${answerArea}</div>
							<div class="result-area mt-3" style="display: none;"></div>
						</div>
					`;
					return card;
				}

				function collectUserAnswers() {
					const userAnswers = [];
					const practiceCards = document.querySelectorAll('.practice-card');

					practiceCards.forEach((card, index) => {
						const question = currentQuestions[index];
						let answer;
						if (question.question_type === 'multiple_choice') {
							const checked = card.querySelector('input[type="radio"]:checked');
							answer = checked ? checked.value : null;
						} else if (question.question_type === 'fill_in_the_blank') {
							const inputs = card.querySelectorAll('.fitb-input');
							answer = Array.from(inputs).map(input => input.value);
						} else if (question.question_type === 'short_answer') {
							answer = card.querySelector('textarea').value;
						}
						userAnswers.push(answer);
					});
					return userAnswers;
				}

				async function submitForGrading() {
					const userAnswers = collectUserAnswers();
					const apiKey = localStorage.getItem('siliconflow_api_key');
					const temperature = localStorage.getItem('llm_temperature') || '0.7';

					// ç¦ç”¨æäº¤æŒ‰é’®
					const submitBtn = document.getElementById('submit-practice-btn');
					submitBtn.disabled = true;
					submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> æ­£åœ¨åˆå§‹åŒ–æ‰¹æ”¹...';
					
					document.querySelectorAll('.practice-card input, .practice-card textarea').forEach(el => el.disabled = true);

					try {
						const response = await fetch('/api/grade', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({
								questions: currentQuestions,
								answers: userAnswers,
								api_key: apiKey,
								temperature: parseFloat(temperature)
							})
						});
						
						if (!response.ok) {
							const errData = await response.json();
							throw new Error(errData.error || 'æ‰¹æ”¹æœåŠ¡è¿æ¥å¤±è´¥');
						}
						
						submitBtn.style.display = 'none';

						const reader = response.body.getReader();
						const decoder = new TextDecoder();
						let buffer = "";
						let gradedCount = 0;

						while (true) {
							const { done, value } = await reader.read();
							if (done) break;

							buffer += decoder.decode(value, { stream: true });
							const lines = buffer.split("\n");
							buffer = lines.pop();

							for (const line of lines) {
								if (line.trim()) {
									try {
										const event = JSON.parse(line);
										const card = document.querySelector(`.practice-card[data-question-index="${event.question_index}"]`);
										if (!card) continue;
										
										const resultArea = card.querySelector('.result-area');

										if (event.type === 'error') {
											resultArea.innerHTML = `<div class="alert alert-danger p-2"><strong>é”™è¯¯:</strong> ${event.error}</div>`;
											resultArea.style.display = 'block';
											gradedCount++;
										} else if (event.type === 'start') {
											resultArea.innerHTML = '<pre style="white-space: pre-wrap; word-wrap: break-word; color: #6c757d;"></pre>';
											resultArea.style.display = 'block';
										} else if (event.type === 'streaming') {
											const pre = resultArea.querySelector('pre');
											if (pre) pre.textContent += event.content;
										} else if (event.type === 'end') {
											displaySingleGradingResult(resultArea, event.data, currentQuestions[event.question_index]);
											gradedCount++;
										}
									} catch (e) {
										console.error("è§£ææˆ–å¤„ç†æ‰¹æ”¹æµæ—¶å‡ºé”™:", e);
									}
								}
							}
						}
						
						if (gradedCount === currentQuestions.length) {
							displayOverallScore();
						}

					} catch(error) {
						alert(`æäº¤æ‰¹æ”¹æ—¶å‡ºé”™: ${error.message}`);
						submitBtn.style.display = 'block';
						submitBtn.disabled = false;
						submitBtn.textContent = 'æäº¤æ‰¹æ”¹';
						document.querySelectorAll('.practice-card input, .practice-card textarea').forEach(el => el.disabled = false);
					}
				}

				function displaySingleGradingResult(resultArea, resultData, questionData) {
					const scoreColor = resultData.score === questionData.score ? 'text-success' : (resultData.score > 0 ? 'text-warning' : 'text-danger');
					let resultHtml = `
						<h5>æ‰¹æ”¹ç»“æœ</h5>
						<p><strong>å¾—åˆ†: <span class="${scoreColor}">${resultData.score}</span> / ${questionData.score}</strong></p>
					`;

					if (questionData.question_type === 'multiple_choice') {
						resultHtml += `<p><strong>æ­£ç¡®ç­”æ¡ˆ:</strong> ${questionData.answer}</p>`;
					} else {
						resultHtml += `<p><strong>å‚è€ƒç­”æ¡ˆ:</strong> ${Array.isArray(questionData.answer) ? questionData.answer.join(', ') : questionData.answer}</p>`;
					}

					resultHtml += `<p><strong>AIç‚¹è¯„:</strong> ${resultData.feedback}</p>`;
					resultArea.innerHTML = resultHtml;
				}
				
				function displayOverallScore() {
					let totalScore = 0;
					let earnedScore = 0;

					document.querySelectorAll('.practice-card').forEach((card, index) => {
						const question = currentQuestions[index];
						totalScore += question.score;
						const scoreSpan = card.querySelector('.result-area span[class*="text-"]');
						if (scoreSpan) {
							earnedScore += parseInt(scoreSpan.textContent, 10) || 0;
						}
					});

					const overallResult = document.createElement('div');
					overallResult.className = 'alert alert-info mt-4';
					overallResult.innerHTML = `<h4>ç»ƒä¹ å®Œæˆï¼</h4><p class="mb-0"><strong>æ€»å¾—åˆ†: ${earnedScore} / ${totalScore}</strong></p>`;
					document.getElementById('questions-container').appendChild(overallResult);
				}

				function addReviewControls() {
					const controlsContainer = document.getElementById("controls-container");
					controlsContainer.innerHTML = ''; // æ¸…ç©ºç°æœ‰æ§ä»¶

					const buttonGroup = document.createElement('div');
					buttonGroup.className = 'mt-4 d-grid gap-2 d-md-flex justify-content-md-center';

					const startBtn = document.createElement('button');
					startBtn.id = 'start-practice-btn';
					startBtn.className = 'btn btn-primary btn-lg';
					startBtn.textContent = 'å¼€å§‹åœ¨çº¿ç»ƒä¹ ';
					startBtn.addEventListener('click', showPracticePage);
					buttonGroup.appendChild(startBtn);

					const exportBtn = document.createElement('button');
					exportBtn.id = 'export-md-btn';
					exportBtn.className = 'btn btn-secondary btn-lg';
					exportBtn.textContent = 'å¯¼å‡ºä¸º Markdown';
					exportBtn.setAttribute('data-bs-toggle', 'modal');
					exportBtn.setAttribute('data-bs-target', '#exportMarkdownModal');
					buttonGroup.appendChild(exportBtn);

					controlsContainer.appendChild(buttonGroup);
				}

				function showReviewPage() {
					const formContainer = document.querySelector(".col-md-4");
					// åœ¨ä»ç»ƒä¹ é¡µé¢è¿”å›æ—¶ï¼Œå®ƒå°†æ˜¯ col-md-12
					const questionsCol = document.querySelector(".col-md-12"); 
					const questionsContainer = document.getElementById("questions-container");
					const controlsContainer = document.getElementById("controls-container");

					formContainer.style.display = "block";
					if (questionsCol) {
						questionsCol.classList.replace("col-md-12", "col-md-8");
					}
					
					questionsContainer.innerHTML = "";
					controlsContainer.innerHTML = "";

					const title = document.createElement("h4");
					title.textContent = "ç”Ÿæˆçš„é¢˜ç›®";
					questionsContainer.appendChild(title);

					currentQuestions.forEach((q, index) => {
						const card = createQuestionCard(q, index + 1);
						questionsContainer.appendChild(card);
					});

					addReviewControls(); // æ·»åŠ "å¼€å§‹ç»ƒä¹ "æŒ‰é’®
				}

				function showPracticePage() {
					const formContainer = document.querySelector(".col-md-4");
					const questionsCol = document.querySelector(".col-md-8");
					const questionsContainer = document.getElementById("questions-container");
					const controlsContainer = document.getElementById("controls-container");

					formContainer.style.display = "none"; // éšè—è¡¨å•
					questionsContainer.innerHTML = ""; // æ¸…ç©ºé¢˜ç›®é¢„è§ˆ
					controlsContainer.innerHTML = ""; // æ¸…ç©º"å¼€å§‹ç»ƒä¹ "æŒ‰é’®

					questionsCol.classList.replace("col-md-8", "col-md-12"); // æ‰©å±•å®½åº¦

					const practiceTitle = document.createElement("h4");
					practiceTitle.textContent = "åœ¨çº¿ç»ƒä¹ ";
					questionsContainer.appendChild(practiceTitle);


					currentQuestions.forEach((q, index) => {
						const card = createPracticeCard(q, index + 1);
						questionsContainer.appendChild(card);
					});

					const buttonGroup = document.createElement('div');
					buttonGroup.className = 'mt-4 text-center';

					const submitBtn = document.createElement('button');
					submitBtn.id = 'submit-practice-btn';
					submitBtn.className = 'btn btn-success btn-lg me-2';
					submitBtn.textContent = 'æäº¤æ‰¹æ”¹';
					submitBtn.addEventListener('click', submitForGrading);
					buttonGroup.appendChild(submitBtn);

					const backBtn = document.createElement('button');
					backBtn.id = 'back-to-review-btn';
					backBtn.className = 'btn btn-secondary btn-lg';
					backBtn.textContent = 'è¿”å›é¢„è§ˆ';
					backBtn.addEventListener('click', showReviewPage);
					buttonGroup.appendChild(backBtn);

					questionsContainer.appendChild(buttonGroup);
				}

				document
					.getElementById("generate-form")
					.addEventListener("submit", async function (event) {
						event.preventDefault();

						const generateBtn = document.getElementById("generate-btn");
						const spinner = generateBtn.querySelector(".spinner-border");
						const questionsContainer = document.getElementById("questions-container");
						const placeholder = document.getElementById("start-generation-placeholder");
						const controlsContainer = document.getElementById("controls-container");

						generateBtn.disabled = true;
						spinner.classList.remove("d-none");
						if (placeholder) {
							placeholder.remove();
						}
						questionsContainer.innerHTML = '<p class="text-center text-primary">æ­£åœ¨è¿æ¥æ¨¡å‹ï¼Œè¯·ç¨å€™...</p>';
						controlsContainer.innerHTML = '';

						const formData = new FormData(this);

						try {
							const response = await fetch("/api/process", {
								method: "POST",
								body: formData,
							});

							if (!response.ok) {
								const errorData = await response.json();
								throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
							}

							questionsContainer.innerHTML = ""; // æ¸…ç©ºç­‰å¾…æç¤º
							currentQuestions = []; // é‡ç½®é¢˜ç›®

							const reader = response.body.getReader();
							const decoder = new TextDecoder();
							let buffer = "";
							let questionCounter = 1;
							let currentCard = null;
							let currentCardBody = null;

							while (true) {
								const { done, value } = await reader.read();
								if (done) break;

								buffer += decoder.decode(value, { stream: true });
								const lines = buffer.split("\n");
								buffer = lines.pop();

								for (const line of lines) {
									if (line.trim()) {
										const event = JSON.parse(line);
										if (event.type === 'error') {
											let errorMessage = event.error || 'ä¸€ä¸ªæœªçŸ¥çš„æµé”™è¯¯å‘ç”Ÿäº†';
											if (event.error_type === 'security') {
												errorMessage = `å†…å®¹å®‰å…¨æ£€æŸ¥æœªé€šè¿‡ï¼š${event.error}`;
											} else if (event.error_type === 'authentication') {
												errorMessage = `API Key è®¤è¯å¤±è´¥ï¼š${event.error}`;
											}
											throw new Error(errorMessage);
										}
										
										if (event.type === 'start') {
											const cardId = `question-card-${questionCounter}`;
											const cardWrapper = document.createElement("div");
											cardWrapper.innerHTML = `
												<div id="${cardId}" class="card mb-3 shadow-sm">
													<div class="card-header">
														<strong>é¢˜ç›® ${questionCounter}</strong>
													</div>
													<div class="card-body">
														<pre style="white-space: pre-wrap; word-wrap: break-word;"></pre>
													</div>
												</div>
											`;
											currentCard = cardWrapper.firstElementChild;
											questionsContainer.appendChild(currentCard);
											currentCardBody = currentCard.querySelector('.card-body pre');

										} else if (event.type === 'streaming' && currentCardBody) {
											currentCardBody.textContent += event.content;
											questionsContainer.scrollTop = questionsContainer.scrollHeight;

										} else if (event.type === 'end' && currentCard) {
											const finalData = event.data;
											currentQuestions.push(finalData); 
											const finalCard = createQuestionCard(finalData, questionCounter);
											currentCard.replaceWith(finalCard);
											
											questionCounter++;
											currentCard = null; 
											currentCardBody = null;
										}
									}
								}
							}
							
							if (currentQuestions.length > 0) {
								addReviewControls();
							}

						} catch (error) {
							alert(`å‡ºé¢˜å¤±è´¥: ${error.message}`);
							questionsContainer.innerHTML = `<div class="alert alert-danger" role="alert"><strong>å‡ºé”™äº†:</strong> ${error.message}</div>`;
						} finally {
							generateBtn.disabled = false;
							spinner.classList.add("d-none");
						}
					});

				function showAlert(message, type = 'info') {
					const alertContainer = document.getElementById('alert-container');
					if (!alertContainer) return;

					// Map custom types to bootstrap alert types
					const alertType = type === 'error' ? 'danger' : type;

					const wrapper = document.createElement('div');
					wrapper.innerHTML = [
						`<div class="alert alert-${alertType} alert-dismissible fade show" role="alert">`,
						`   <div>${message}</div>`,
						'   <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>',
						'</div>'
					].join('');

					alertContainer.append(wrapper);

					// Automatically remove the alert after 5 seconds
					setTimeout(() => {
						const alert = wrapper.querySelector('.alert');
						if (alert) {
							bootstrap.Alert.getOrCreateInstance(alert).close();
						}
					}, 5000);
				}

				async function handleRegenerateClick(button, action) {
					const card = button.closest('.card');
					const questionIndex = parseInt(card.dataset.questionIndex, 10);
					const originalQuestion = currentQuestions[questionIndex];
					
					const apiKey = localStorage.getItem('siliconflow_api_key');
					if (!apiKey) {
						alert('è¯·è¾“å…¥API Key');
						return;
					}

					const userRequirement = document.getElementById('user_input').value || 'æ— ç‰¹å®šè¦æ±‚';
					
					// æ‰¾åˆ°è¦è¢«æ›¿æ¢çš„åŸå§‹å¡ç‰‡
					const originalCard = document.querySelector(`.card[data-question-index='${questionIndex}']`);
					if (!originalCard) return;


					// 1. ç›´æ¥åˆ›å»ºéª¨æ¶å¡ç‰‡
					const skeletonCard = document.createElement('div');
					skeletonCard.className = 'card mb-3 shadow-sm';
					skeletonCard.dataset.questionIndex = questionIndex;
					skeletonCard.innerHTML = `
						<div class="card-header">
							<strong>é¢˜ç›® ${questionIndex + 1} (æ­£åœ¨é‡æ–°ç”Ÿæˆ...)</strong>
						</div>
						<div class="card-body">
							<pre style="white-space: pre-wrap; word-wrap: break-word; color: #6c757d;"></pre>
						</div>
					`;

					// 2. ç«‹å³æ›¿æ¢åŸå§‹å¡ç‰‡
					originalCard.replaceWith(skeletonCard);
					const preElement = skeletonCard.querySelector('pre');

					try {
						// 3. å¼€å§‹è¯·æ±‚
						const response = await fetch('/api/regenerate_question', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({
								question: originalQuestion,
								action: action,
								user_requirement: userRequirement,
								api_key: apiKey
							})
						});

						if (!response.ok) {
							const errorData = await response.json();
							throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
						}
						
						const reader = response.body.getReader();
						const decoder = new TextDecoder();
						let buffer = "";
						
						// æ¸…ç©º pre æ ‡ç­¾çš„åˆå§‹å†…å®¹
						if(preElement) preElement.textContent = '';

						while (true) {
							const { done, value } = await reader.read();
							if (done) break;

							buffer += decoder.decode(value, { stream: true });
							const lines = buffer.split("\n");
							buffer = lines.pop();

							for (const line of lines) {
								if (line.trim()) {
									// JSON.parseå¯èƒ½ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¦‚æœæµæ•°æ®ä¸å®Œæ•´
									try {
										const event = JSON.parse(line);
										if (event.type === 'error') throw new Error(event.error || 'æµå¤„ç†é”™è¯¯');
										
										if (event.type === 'streaming' && preElement) {
											preElement.textContent += event.content;
										} else if (event.type === 'end') {
											const newQuestionData = event.data;
											const newCard = createQuestionCard(newQuestionData, questionIndex + 1);
											
											// æœ€ç»ˆæ›¿æ¢éª¨æ¶å¡ç‰‡
											const cardToReplace = document.querySelector(`.card[data-question-index='${questionIndex}']`);
											if(cardToReplace) cardToReplace.replaceWith(newCard);
											
											// æ›´æ–°å…¨å±€é¢˜ç›®åˆ—è¡¨
											currentQuestions[questionIndex] = newQuestionData;
										}
									} catch(e) {
										// å¿½ç•¥JSONè§£æé”™è¯¯ï¼Œç­‰å¾…æ›´å¤šæ•°æ®
										console.warn("JSON parsing error in stream, waiting for more data...", line);
									}
								}
							}
						}
					} catch (error) {
						alert(`æ“ä½œå¤±è´¥: ${error.message}`);
						// å‡ºé”™æ—¶ï¼Œæ¢å¤ä¸ºåŸå§‹å¡ç‰‡
						const finalCard = createQuestionCard(originalQuestion, questionIndex + 1);
						const cardToReplace = document.querySelector(`.card[data-question-index='${questionIndex}']`);
						if(cardToReplace) cardToReplace.replaceWith(finalCard);
					}
				}
			});
		</script>
	</body>
</html>


